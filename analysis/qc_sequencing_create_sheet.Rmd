---
output:
  html_document:
    toc: true
    toc_depth: 4
version: 0.1.1
author: Tamas Ryszard Sztanka-Toth, Nikolaos Karaiskos
email: tamasryszard.sztanka-toth@mdc-berlin.de, nikolaos.karaiskos@mdc.berlin.de
license: GPL
---

```{r knitr_options, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(
  autodep = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = NA
)
```

```{r libraries, include = F, cache=F}
library(tidyverse)
library(yaml)
library(knitr)
library(magrittr)
library(kableExtra)
library(cowplot)
library(grid)
library(gtable)

theme_set(theme_cowplot(12))

cpalette <- list('orange' = '#D55E00', 'blue' = '#0072B2', 'green' = '#009E73', 'black' = '#000000', 'yellow' = '#F0E442', 
				 'grey' = '#999999', 'light_orange' = "#E69F00", 'light_blue' = "#56B4E9")

readStarLog <- function(log_file){

		out = list()
		lines = readLines(log_file)
	
		out$input_reads = (lines[6] %>% strsplit('\t') %>% unlist)[2] %>% as.integer

		out$uniq_mapped_reads = (lines[9] %>% strsplit('\t') %>% unlist)[2] %>% as.integer

		#out$avg_length = (lines[11] %>% strsplit('\t') %>% unlist)[2] %>% as.numeric
		
        tibble(observation=names(out), value=unlist(unname(out)))
	}
shift_legend <- function(p){

  # check if p is a valid object
  if(!"gtable" %in% class(p)){
    if("ggplot" %in% class(p)){
      gp <- ggplotGrob(p) # convert to grob
    } else {
      message("This is neither a ggplot object nor a grob generated from ggplotGrob. Returning original plot.")
      return(p)
    }
  } else {
    gp <- p
  }

  # check for unfilled facet panels
  facet.panels <- grep("^panel", gp[["layout"]][["name"]])
  empty.facet.panels <- sapply(facet.panels, function(i) "zeroGrob" %in% class(gp[["grobs"]][[i]]))
  empty.facet.panels <- facet.panels[empty.facet.panels]
  if(length(empty.facet.panels) == 0){
    message("There are no unfilled facet panels to shift legend into. Returning original plot.")
    return(p)
  }

  # establish extent of unfilled facet panels (including any axis cells in between)
  empty.facet.panels <- gp[["layout"]][empty.facet.panels, ]
  empty.facet.panels <- list(min(empty.facet.panels[["t"]]), min(empty.facet.panels[["l"]]),
                             max(empty.facet.panels[["b"]]), max(empty.facet.panels[["r"]]))
  names(empty.facet.panels) <- c("t", "l", "b", "r")

  # extract legend & copy over to location of unfilled facet panels
  guide.grob <- which(gp[["layout"]][["name"]] == "guide-box")
  if(length(guide.grob) == 0){
    message("There is no legend present. Returning original plot.")
    return(p)
  }
  gp <- gtable_add_grob(x = gp,
                        grobs = gp[["grobs"]][[guide.grob]],
                        t = empty.facet.panels[["t"]],
                        l = empty.facet.panels[["l"]],
                        b = empty.facet.panels[["b"]],
                        r = empty.facet.panels[["r"]],
                        name = "new-guide-box")

  # squash the original guide box's row / column (whichever applicable)
  # & empty its cell
  guide.grob <- gp[["layout"]][guide.grob, ]
  if(guide.grob[["l"]] == guide.grob[["r"]]){
    gp <- gtable_squash_cols(gp, cols = guide.grob[["l"]])
  }
  if(guide.grob[["t"]] == guide.grob[["b"]]){
    gp <- gtable_squash_rows(gp, rows = guide.grob[["t"]])
  }
  gp <- gtable_remove_grobs(gp, "guide-box")

  return(gp)
}
```

```{r save_snakemake, echo = F}
#write_rds(snakemake, '/scratch/home/tsztank/snakemake.rds')
snakemake <- read_rds('/scratch/home/tsztank/snakemake.rds')
```

### Overview

```{r read_qc_parameters_yaml, echo = F}
parameters <- read_yaml(snakemake@input$parameters_file)

parameter_stats <- parameters %>%
    as_tibble() %>%
    gather('metric', 'value')

cPalette = list('grey'= "#999999", 'light_orange'="#E69F00",
         'light_blue'="#56B4E9", 'green' = "#009E73",
         'yellow' = "#F0E442", 'blue'= "#0072B2", 'orange'="#D55E00",
         'pink'="#CC79A7")

clrs = c('umis'=cPalette$light_orange, 'pcr' = cPalette$light_blue, 'reads'=cPalette$green,
         'genes'=cPalette$pink, 'n_beads'= 'black')

median_clrs = clrs
names(median_clrs) = paste0('median_', names(clrs))

nucl_clrs = c('A'='#F5C900',
              'C'='#F55D59',
              'T'='#3AA861',
              'G'='#7772F5',
              'N'='#999999')
```

```{r plot_read_statistics, echo =F}
rRNA_stats <- read_table2(snakemake@input$ribo_log, col_names=c('observation', 'value')) %>%
    spread(observation, value) %>%
    mutate(mapped_to_rRNA = aligned_reads) %>%
    gather('observation', 'value') %>%
    filter(observation == 'mapped_to_rRNA') %>%
    mutate(value = ifelse(value == 'None', 0, value))
 
read_stats <- readStarLog(snakemake@input$star_log) %>%
    rbind(rRNA_stats) %>%
    rbind(read_table2(snakemake@input$reads_type_out, col_names=c('observation', 'value'))) %>%
    # convert to millions
    mutate(value = round(value / 1e6, 2)) %>%
    {
        mutate(., input_reads = filter(., observation == 'input_reads')$value)
    } %>%
    mutate(label = ifelse(observation == 'input_reads', value, paste0(value, ' (', round(value/input_reads*100, 1), '%)'))) %>%
    dplyr::select(observation, label) %>%
    spread(observation, label) %>%
    dplyr::rename(as.utr = UTR,
                  intronic = INTRONIC,
                  intergenic = INTERGENIC,
                  ambiguous = AMB,
                  as.cds = CODING) %>%
    # reorder columns
    dplyr::select(input_reads, uniq_mapped_reads, mapped_to_rRNA, intergenic, intronic, as.cds, ambiguous, as.utr) %>%
    gather('metric', 'value')

parameter_stats %>%
    bind_rows(read_stats) %>%
    kbl(col.names=NULL) %>%
    kable_classic_2(full_width=F) %>%
    pack_rows('Sample info', 1, 7) %>%
    pack_rows('Read statistics', 8, 15)
```

### QC plots

#### 'Knee'-plot

Expected number of barcodes is `r parameters$expected_n_beads`, here we plot a Knee-plot with `r parameters$expected_n_beads` beads.

```{r knee_plot, echo = F}
read_counts <- read_table2(snakemake@input$read_counts, skip=1, col_names=c('reads', 'cell_bc')) %>%
    mutate(reads_cumsum = cumsum(reads),
           ix = 1:n())

read_counts %>%
    slice_head(n=parameters$expected_n_beads) %>%
    ggplot(aes(ix, reads_cumsum)) +
        geom_line() +
        ggtitle(paste0('Knee-plot, top ', parameters$expected_n_beads, ' beads')) +
        labs(x='Beads sorted by number of reads', y='Cummulative fraction of reads')
```

#### Umi-cutoff plots

```{r umi_cutoff_plot, echo = F, fig.width = 10, fig.height=5, dpi=300}
umi_cutoffs <- seq(0, 1000, 10)

dge_summary <- read_table2(snakemake@input$dge_all_summary, skip=7, col_names = c('cell_bc', 'reads', 'umis', 'genes')) %>%
    mutate(pcr = reads/ umis)

cell_bc_len = nchar((dge_summary %$% cell_bc)[1])

dge_summary <- dge_summary %>%
    filter(nchar(cell_bc) == cell_bc_len) %>%
    mutate(quartile = ntile(1:n(), 4))

summarise_dge_summary <- function(umi_cutoff){
    dge_summary %>%
        filter(umis > umi_cutoff) %>%
        summarise(median_reads = median(reads),
                  median_umis = median(umis),
                  median_genes = median(genes),
                  median_pcr = median(pcr),
                  n_beads = n())
}

umi_cutoff_data <- tibble(umi_cutoffs = umi_cutoffs) %>%
    mutate(dat = map(umi_cutoffs, ~ summarise_dge_summary(.))) %>%
    unnest(dat)

p <- umi_cutoff_data %>%
    gather('obs', 'value', -umi_cutoffs) %>%
    ggplot(aes(umi_cutoffs, value, color=obs)) +
        geom_line() +
        scale_color_manual(values=median_clrs) +
        facet_wrap(~obs, ncol=3, scales='free') +
        ggtitle('Summarised metrics based on minimum UMI cutoff') + 
        theme(strip.background=element_blank(), strip.text.x=element_blank(),
              text = element_text(size=18, face = 'plain')) +
        labs(color='') +
        guides(colour = guide_legend(override.aes = list(size=5)))

grid.draw(shift_legend(p))
```

#### Histogram of metrics over beads

```{r plot_n_reads_bead_hist, echo = F, fig.width=10, dpi=300}
to_plot <- dge_summary %>%
    gather('obs', 'val', -cell_bc, -quartile)

min_difference <- to_plot %>% group_by(obs) %>%
    summarise(min_val = min(val),
              max_val = max(val),
              difference = max_val - min_val) %>%
    summarise(min_difference = min(difference)) %$%
    min_difference

pl <- to_plot %>%
    ggplot(aes(x = val, fill=obs)) +
        geom_histogram(bins=100) +
        scale_x_log10() +
        scale_fill_manual(values=clrs) +
        facet_wrap(~obs, ncol=2, scales='free') +
        ggtitle('Histogram of metrics',
                subtitle=paste0('Over all beads (n=',nrow(dge_summary), ')')) +
        theme(legend.position = 'bottom', text = element_text(size=18, face='plain'))

# if min_difference is bigger than 1, we can add logtick annotation. otherwise we cant,
# as R will complain (too little ticks to be added)
if(min_difference > 1){
    pl <- pl + 
        annotation_logticks(sides='b')
}

print(pl)
```

#### Nucleotide distribution per beads

```{r plot_nucl_freq, echo = F, fig.height=7, fig.width=10}
nucls <- dge_summary %$%
    cell_bc %>% strsplit("")

nucls <- dge_summary %>%
    select(cell_bc, quartile) %>%
    bind_cols(tibble(nucl=nucls)) %>%
    unnest(nucl) %>%
    group_by(cell_bc) %>%
    mutate(pos = paste0('pos_', 100+1:n())) %>%
    group_by(pos, nucl, quartile) %>%
    summarise(nucl_count = n()) %>%
    ungroup() %>%
    tidyr::complete(pos, nucl, quartile, fill=list(nucl_count=0))

nucls %>%
    ggplot(aes(pos, nucl_count, fill = nucl)) +
        geom_bar(stat='identity', position='dodge') +
        scale_fill_manual(values=nucl_clrs) +
        scale_x_discrete(labels=seq(1, cell_bc_len, 1)) +
        facet_wrap(~quartile, ncol=2) +
        ggtitle('Nucleotide distributions per nucleotide position and bead quartile')
```

#### Shannon entropy and string compression

```{r calc_shannon, echo = F}
calc_shannon_entropy <- function(barcode){
    counts <- strsplit(barcode, '')[[1]] %>% table
    len <- nchar(barcode) 

    (-1*sum(counts/len * log2(counts/len)))
}

calc_string_compression <- function(barcode){
    barcode_vector <- strsplit(barcode, '')[[1]]
    res <- rle(barcode_vector)
    compressed_barcode <- paste(res$values, res$lengths, collapse='', sep='')

    return(nchar(compressed_barcode))
}

theoretical <- c()
    
for(i in seq(1, dge_summary %>% nrow, 1)){
    theoretical[i] = paste(sample(c('A', 'C', 'T', 'G'), cell_bc_len, T), collapse='')
}

dge_summary <- dge_summary %>%
    add_column(theoretical_entropy = map(theoretical, ~ calc_shannon_entropy(.))) %>%
    mutate(exact_entropy = map(cell_bc, ~ calc_shannon_entropy(.))) %>%
    unnest(exact_entropy) %>%
    unnest(theoretical_entropy) %>%
    add_column(theoretical_string_compression = map(theoretical, ~ calc_string_compression(.))) %>%
    mutate(exact_string_compression = map(cell_bc, ~calc_string_compression(.))) %>%
    unnest(exact_string_compression) %>%
    unnest(theoretical_string_compression)
```

```{r plot_shannon, echo = F}
dge_summary %>%
    dplyr::select(-reads, -umis, -genes, -pcr, -quartile) %>%
    gather('observation', 'value', -cell_bc) %>%
    # replace first _ with |, so we can separate later
    mutate(observation = str_replace(observation, '_', ' '),
           observation = str_replace(observation, '\\s', '|'),
           observation = str_replace(observation, ' ', '_')) %>%
    separate(observation, into = c('type', 'observation'), sep = '\\|') %>%
    ggplot(aes(value, fill = type)) +
        geom_histogram(bins=30, color='black', position='dodge') +
        scale_fill_manual(values=c(cpalette$grey, cpalette$orange)) +
        ggtitle('Shannon entropy and string compression',
                subtitle='histograms over all beads') +
        facet_wrap(~observation, ncol = 1, scales='free') +
        labs(fill='')
```

