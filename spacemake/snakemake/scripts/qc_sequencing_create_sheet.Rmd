---
output:
  html_document:
    toc: true
    self_contained: yes
    toc_depth: 4
version: 0.2.0
author: Tamas Ryszard Sztanka-Toth, Nikolaos Karaiskos
email: tamasryszard.sztanka-toth@mdc-berlin.de, nikolaos.karaiskos@mdc.berlin.de
license: GPL
---

```{r knitr_options, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(
  autodep = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = NA
)
```

```{r libraries, include = F, cache=F}
library(tidyverse)
library(yaml)
library(knitr)
library(magrittr)
library(kableExtra)
library(cowplot)

theme_set(theme_cowplot(18))

cpalette <- list('orange' = '#D55E00', 'blue' = '#0072B2', 'green' = '#009E73', 'black' = '#000000', 'yellow' = '#F0E442', 
				 'grey' = '#999999', 'light_orange' = "#E69F00", 'light_blue' = "#56B4E9")

readStarLog <- function(log_file){

		out = list()
		lines = readLines(log_file)
	
		out$input_reads = (lines[6] %>% strsplit('\t') %>% unlist)[2] %>% as.integer

		out$uniq_mapped_reads = (lines[9] %>% strsplit('\t') %>% unlist)[2] %>% as.integer

        out$multi_mapped_reads = (lines[24] %>% strsplit('\t') %>% unlist)[2] %>% as.integer

		out$avg_mapped_length = (lines[11] %>% strsplit('\t') %>% unlist)[2] %>% as.numeric

        out$unmapped_too_short = (lines[31] %>% strsplit('\t') %>% unlist)[2] %>% as.integer
		
        tibble(observation=names(out), value=unlist(unname(out)))
	}
```

```{r read_sample_information_tables, echo = F}
run_mode_settings <- bind_rows(snakemake@params$run_mode) %>%
    nest(umi_cutoff = c(umi_cutoff)) %>%
    bind_cols(tibble(run_mode = names(snakemake@params$run_mode))) %>%
    gather('variable_name', 'value', -run_mode) %>%
    spread(run_mode, value)

run_mode_names <- run_mode_settings[-1] %>% names
run_mode_n <- length(run_mode_names)

sample_info <- bind_rows(snakemake@params$sample_info) %>%
    select(species, sequencing_date, investigator, experiment,
           puck_barcode_file) %>%
    unique %>%
    gather('info_name', 'value') %>%
    add_row(info_name = 'project_id',
            value = snakemake@wildcards$project, .before=1)%>%
    add_row(info_name = 'sample_id',
            value = snakemake@wildcards$sample, .after=1)%>%
    add_row(info_name = 'puck_id',
            value = snakemake@wildcards$puck, .after=2)

cPalette = list('grey'= "#999999", 'light_orange'="#E69F00",
         'light_blue'="#56B4E9", 'green' = "#009E73",
         'yellow' = "#F0E442", 'blue'= "#0072B2", 'orange'="#D55E00",
         'pink'="#CC79A7")

clrs = c('umis'=cPalette$light_orange, 'genes' = cPalette$light_blue, 'reads'=cPalette$green,
         'pcr'=cPalette$pink)

summarised_clrs = c(clrs, 'black')
names(summarised_clrs) = c(paste0('median_', names(clrs)), 'n_beads')

nucl_clrs = c('A'='#F5C900',
              'C'='#F55D59',
              'T'='#3AA861',
              'G'='#7772F5',
              'N'='#999999')
```

### Overview {.tabset}

#### Sample info

```{r show_sample_info, echo = F}
sample_info %>%
    filter(info_name != 'puck_barcode_file') %>%
    kbl(col.names=NULL) %>%
    kable_classic_2(full_width=F, position='left')
```

#### Run modes

This sample was processed using the following run modes, and run mode variables

```{r plot_run_modes, echo = F}
col_names_to_show <- colnames(run_mode_settings)[-1]

run_mode_settings %>%
    kbl(col.names = c('', col_names_to_show)) %>%
    kable_classic_2(full_width=F, position='left') %>%
    add_header_above(c(" ", "Run modes" = length(col_names_to_show))) %>%
    column_spec(1, border_right=T) %>%
    row_spec(0, bold=T)
```

```{r load_read_statistics, echo =F}
rRNA_stats <- read_table2(snakemake@input$ribo_log, col_names=c('observation', 'value')) %>%
    spread(observation, value) %>%
    mutate(mapped_to_rRNA = aligned_reads) %>%
    gather('observation', 'value') %>%
    filter(observation == 'mapped_to_rRNA') %>%
    mutate(value = ifelse(value == 'None', 0, value))
 
read_stats <- tibble(star_logs = snakemake@input$star_log,
                     reads_type_out = snakemake@input$reads_type_out) %>%
    mutate(trimmed = ifelse(grepl('polyA_adapter_trimmed', reads_type_out, fixed=TRUE),
                            'polyA_adapter_trimmed', 'untrimmed')) %>%
    mutate(star_log_dat = map(star_logs, ~ readStarLog(.)),
           reads_type_out_dat = map(reads_type_out, ~ read_table2(.,
                                                                  col_names = c('observation',
                                                                                'value')))) %>%
    mutate(rRNA_stats_dat = map(star_logs, ~ rbind(rRNA_stats))) %>%
    select(-star_logs, -reads_type_out) %>%
    gather('dat_type', 'dat', -trimmed) %>%
    select(-dat_type) %>%
    unnest(dat) %>%
    group_by(trimmed) %>%
    #rbind(rRNA_stats) %>%
    # convert to millions
    mutate(value = ifelse(observation != 'avg_mapped_length',
                          round(value / 1e6, 2), value)) %>%
    # add input_reads as a column per group
    spread(observation, value) %>%
    mutate(inp_reads = input_reads) %>%
    gather('observation', 'value', -trimmed, -inp_reads) %>%
    mutate(label = ifelse(observation %in% c('input_reads', 'avg_mapped_length'),
                          value, paste0(value, ' (', round(value/inp_reads*100, 1), '%)'))) %>%
    dplyr::select(observation, label) %>%
    spread(observation, label) %>%
    dplyr::rename(as.utr = UTR,
                  intronic = INTRONIC,
                  intergenic = INTERGENIC,
                  ambiguous = AMB,
                  as.cds = CODING) %>%
    # reorder columns
    dplyr::select(input_reads, uniq_mapped_reads, avg_mapped_length, multi_mapped_reads, 
                  unmapped_too_short, intergenic, intronic, as.cds, ambiguous, as.utr,
                  mapped_to_rRNA) %>%
    gather('metric', 'value', -trimmed) %>%
    spread(trimmed, value) %>%
    # change order
    slice(5, 10, 2,3,7,6,1,4,9,11,8)

map_types = colnames(select(read_stats, -metric))
```

#### Mapping statistics

The sample was mapped using `r map_types` reads. The mapping statistics are shown here for each method:

```{r show_read_stats, echo = F}
col_names_to_show <- colnames(read_stats)[-1]
read_stats %>%
    kbl(col.names = c('', col_names_to_show)) %>%
    kable_classic_2(full_width=F, position='left') %>%
    add_header_above(c(" ", "Mapping mode" = length(col_names_to_show))) %>%
    column_spec(1, border_right=T) %>%
    row_spec(0, bold=T) %>%
    add_indent(c(3,4,5,6,7)) %>%
    footnote(general ='All values, except avg_mapped_length, shown in millions')
```


### QC plots {.tabset}

Each of the QC plots we show on a per run mode basis, to see if there are any downstream differences based on the run mode variable settings.

#### 'Knee'-plot

```{r knee_plot, echo = F, fig.height=4, fig.width = 4*run_mode_n}
dge_summary <- tibble(run_mode = run_mode_names,
                      dge_summary_file = snakemake@input[paste0(run_mode, '.dge_summary')]) %>%
    unnest(dge_summary_file) %>%
    mutate(dat = map(dge_summary_file, ~ read_table2(.,
                                                     skip=7,
                                                     col_names = c('cell_bc', 'reads',
                                                                   'umis', 'genes')))) %>%
    unnest(dat) %>%
    select(-dge_summary_file) %>%
    mutate(pcr = reads/ umis) %>%
    group_by(run_mode)


read_counts <- dge_summary %>%
    select(run_mode, cell_bc, reads) %>%
    mutate(reads_cumsum = cumsum(reads),
           ix = 1:n())

read_counts %>%
    ggplot(aes(ix, reads_cumsum)) +
        geom_line() +
        ggtitle(paste0('Knee-plot, top  beads')) +
        labs(x='Beads sorted by number of reads', y='Cummulative sum of reads') +
        facet_wrap(~run_mode)
```

#### Umi-cutoff plots

```{r create_umi_cutoffs, echo = F, fig.width = 10, fig.height=5}
umi_cutoffs <- seq(10, 20000, 10)

cell_bc_len = nchar((dge_summary %$% cell_bc)[1])

dge_summary <- dge_summary %>%
    filter(nchar(cell_bc) == cell_bc_len) %>%
    group_by(run_mode) %>%
    mutate(reads_cumsum = cumsum(reads)) %>%
    mutate(quartile = cut(reads_cumsum,
                          breaks = 4,
                          include.lowest= T,
                          labels = c('Q1', 'Q2', 'Q3', 'Q4'))) %>%
    select(-reads_cumsum)

summarise_dge_summary <- function(umi_cutoff){
    dge_summary %>%
        filter(umis > umi_cutoff) %>%
        summarise(median_reads = median(reads),
                  median_umis = median(umis),
                  median_genes = median(genes),
                  median_pcr = median(pcr),
                  n_beads = n())
}

umi_cutoff_data <- tibble(umi_cutoffs = umi_cutoffs) %>%
    mutate(dat = map(umi_cutoffs, ~ summarise_dge_summary(.))) %>%
    unnest(dat)

```


```{r plot_umi_cutoff_plot, echo = F, fig.height=7.5, fig.width=12}
umi_cutoff_plot <- function(metric, y_log_transform = F, legend_pos='none'){
    pl <- umi_cutoff_data %>%
        gather('obs', 'value', -umi_cutoffs, -run_mode) %>%
        filter(obs == metric) %>%
        ggplot(aes(umi_cutoffs, value, color=obs, linetype = run_mode)) +
            geom_line() +
            scale_color_manual(values=summarised_clrs) +
            scale_x_log10(breaks = c(1e1, 1e2, 1e3, 1e4)) +
            theme(strip.background=element_blank(), strip.text.x=element_blank(),
                  text = element_text(size=18, face = 'plain'), legend.position=legend_pos,
                  legend.title = element_blank(), legend.margin = margin(t=0.5, b=0.5,l=0.5,
                                                                         r=0.5, unit = 'cm'),
                  legend.spacing = unit(0, 'cm'), plot.margin = unit(c(1,1,1,1), "lines")) +
            labs(color='', linetype='', y=paste0(metric, '\nper spot'), x='minimum umi value per spot') +
            guides(linetype = guide_legend(override.aes = list(size = 1)),
                   color = guide_legend(override.aes = list(size = 2)))

    if (y_log_transform){
        pl <- pl + scale_y_log10() +
            annotation_logticks(sides='bl')
    } else {
        pl <- pl +
            annotation_logticks(sides='b')
    }

    return(pl)
}

pl1 <- umi_cutoff_plot('n_beads', y_log_transform = T)
pl2 <- umi_cutoff_plot('median_reads')
pl3 <- umi_cutoff_plot('median_genes')
pl4 <- umi_cutoff_plot('median_umis')
pl5 <- umi_cutoff_plot('median_pcr', legend_pos = 'right')

plt_legend <- get_legend(pl5)

plot_grid(pl1, pl2, pl3,
        pl4, pl5 + theme(legend.position='none'), plt_legend,
        align='vh', hjust=-1, labels="", nrow=3)
```

#### Histogram of metrics over beads

Next we show mertics such as number of UMIs, genes, reads and pcr per physical spot. We further distinguish between each run mode, showing one histogram for each. 

```{r plot_n_reads_bead_hist, echo = F, fig.width=12, fig.height=5*run_mode_n, dpi=200}
to_plot <- dge_summary %>%
    gather('obs', 'val', -cell_bc, -quartile, -run_mode)

min_difference <- to_plot %>% group_by(obs) %>%
    summarise(min_val = min(val,na.rm=T ),
              max_val = max(val,na.rm=T),
              difference = max_val - min_val) %>%
    summarise(min_difference = min(difference)) %$%
    min_difference

metric_plot <- function(metric, legend_pos='none'){
    pl <- to_plot %>%
        filter(obs == metric) %>%
        ggplot(aes(x = val, fill=obs)) +
            geom_histogram(bins=100) +
            scale_x_log10() +
            scale_fill_manual(values=clrs) +
            facet_wrap(~run_mode, scales='free_y', ncol=1) +
            labs(x=paste0('# of ', metric, ' per spot'), y='# of spots') +
            theme(legend.position = legend_pos)

    if(min_difference > 1){
        pl <- pl + 
            annotation_logticks(sides='b')
    }

    return(pl)
}
pl1 = metric_plot('reads')
pl2 = metric_plot('pcr')
pl3 = metric_plot('genes', 'bottom')
pl4 = metric_plot('umis')

plt_legend <- get_legend(pl3)

pl_metrics <- plot_grid(pl1, pl2, pl3 + theme(legend.position='none'),
                        pl4, align='vh', hjust=-1, labels="", nrow=2)

plot_grid(pl_metrics, plt_legend, ncol=1, rel_heights = c(1, .1))
```

#### Nucleotide distribution per beads {.tabset .tabset-dropdown}

Next we bin the data based on reads into quartile. For each run\_mode the data is divided into 4 beads, by reads. This means, that the first bin will contain beads which account 25% of the reads, the second will contain beads which account for the second 25% of reads and so on. 

For each run mode we plot the nucleotide distribution per quartile.

**You can pick the run\_mode to be shown from the dropdown list**

```{r prepare_nucl_freq, echo = F}
nucls <- dge_summary %$%
    cell_bc %>% strsplit("")

nucls <- dge_summary %>%
    select(cell_bc, quartile, run_mode) %>%
    bind_cols(tibble(nucl=nucls)) %>%
    unnest(nucl) %>%
    # group by run_mode and cell_bc, so each nt is on the correct pos
    group_by(run_mode, cell_bc) %>%
    mutate(pos = paste0('pos_', 100+1:n())) %>%
    group_by(run_mode, pos, nucl, quartile) %>%
    summarise(nucl_count = n()) %>%
    ungroup() %>%
    tidyr::complete(run_mode, pos, nucl, quartile, fill=list(nucl_count=0))

```

```{r plot_nucl_freq, results='asis', fig.width=10, fig.height = 5, echo=F}
plot_nucl_freq <- function(run_mode_in){
    lbl_df <- dge_summary %>%
        ungroup() %>%
        filter(run_mode == run_mode_in) %>%
        group_by(quartile) %>%
        summarise(lbl = n()) %>%
        mutate(lbl = paste0(quartile, ' (n=', lbl, ')'))

    lbls <- lbl_df$lbl
    names(lbls) <- lbl_df$quartile

    nucls %>%
        filter(run_mode == run_mode_in) %>%
        ggplot(aes(pos, nucl_count, fill = nucl)) +
            geom_bar(stat='identity', position='dodge') +
            scale_fill_manual(values=nucl_clrs) +
            scale_x_discrete(labels=seq(1, cell_bc_len, 1)) +
            facet_wrap(~quartile, ncol=2, scales='free_y',
                       labeller=as_labeller(lbls)) +
            labs(x='nucleotide position in the barcode',
                 y='nucletide count')+
            theme(text = element_text(size =18 ))
}

for (run_mode in unique(dge_summary$run_mode)){
    cat (paste0('\n\n ##### ', run_mode, '\n\n'))

    print(plot_nucl_freq(run_mode))
}

```

#### Shannon entropy and string compression {.tabset .tabset-dropdown}

```{r calc_shannon, echo = F}
calc_shannon_entropy <- function(barcode){
    counts <- strsplit(barcode, '')[[1]] %>% table
    len <- nchar(barcode) 

    (-1*sum(counts/len * log2(counts/len)))
}

calc_string_compression <- function(barcode){
    barcode_vector <- strsplit(barcode, '')[[1]]
    res <- rle(barcode_vector)
    compressed_barcode <- paste(res$values, res$lengths, collapse='', sep='')

    return(nchar(compressed_barcode))
}

theoretical <- c()
    
for(i in seq(1, dge_summary %>% nrow, 1)){
    theoretical[i] = paste(sample(c('A', 'C', 'T', 'G'), cell_bc_len, T), collapse='')
}

dge_summary <- dge_summary %>%
    add_column(theoretical_entropy = map(theoretical, ~ calc_shannon_entropy(.))) %>%
    mutate(exact_entropy = map(cell_bc, ~ calc_shannon_entropy(.))) %>%
    unnest(exact_entropy) %>%
    unnest(theoretical_entropy) %>%
    add_column(theoretical_string_compression = map(theoretical, ~ calc_string_compression(.))) %>%
    mutate(exact_string_compression = map(cell_bc, ~calc_string_compression(.))) %>%
    unnest(exact_string_compression) %>%
    unnest(theoretical_string_compression)
```

```{r plot_shannon, echo = F, fig.height=5, fig.width=10, results='asis'}
plot_shannon_scompression <- function(run_mode_in){
    dat <- dge_summary %>%
        filter(run_mode == run_mode_in) %>%
        dplyr::select(-reads, -umis, -genes, -pcr, -quartile) %>%
        gather('observation', 'value', -cell_bc, -run_mode) %>%
        # replace first _ with |, so we can separate later
        mutate(observation = str_replace(observation, '_', ' '),
               observation = str_replace(observation, '\\s', '|'),
               observation = str_replace(observation, ' ', '_')) %>%
        separate(observation, into = c('type', 'observation'), sep = '\\|')

    pl1 <- dat %>%
        filter(observation == 'entropy') %>%
        ggplot(aes(value, fill = type)) +
            geom_histogram(bins=30, color='black', position='dodge') +
            scale_fill_manual(values=c(cpalette$grey, cpalette$orange)) +
            labs(fill='', y='# of beads', x='shannon entropy of beads') +
            theme(legend.position = c(0.1, 0.8), text = element_text(size=18, face='plain'))

    pl2 <- dat %>%
        filter(observation == 'string_compression') %>%
        ggplot(aes(value, fill = type)) +
            geom_histogram(bins=30, color='black', position='dodge') +
            scale_fill_manual(values=c(cpalette$grey, cpalette$orange)) +
            labs(fill='', y='# of beads', x='length of beads after compression') +
            theme(text = element_text(size=18, face='plain'), legend.position='none')

    plt_legend <- get_legend(pl2)

    plot_grid(pl1, pl2,
              align='vh', hjust=-1, labels="", nrow=2)

}

for (run_mode in unique(dge_summary$run_mode)){
    cat (paste0('\n\n ##### ', run_mode, '\n\n'))

    print(plot_shannon_scompression(run_mode))
}
```

