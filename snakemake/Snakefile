# snakemake root file to create pipeline for the spatial sequencing illumina data
#
# author: tsztank
# email: tamasryszard.sztanka-toth@mdc-berlin.de
#
# ###

####
# import necessary python packages
####
import os
from sample_sheet import SampleSheet

def get_samples(runs):
    out_dict = {}
    for key in runs.keys():
        out_dict[key] = [sample['Sample_ID'] for sample in SampleSheet(runs[key]['samplesheet']).samples]

    return(out_dict)

####
# this file should contain all sample information, sample name etc.
####
configfile: 'config.yaml'

###############
# Global vars #
###############
# set root output dir
root_dir = 'data'

# runs as a dictionary
runs = config['illumina_runs']

# get the samples
samples = get_samples(runs) 

# demultiplexing root. for each run we demultiplex only once
demux_out = root_dir + '/{run}/demux_data'

# Undetermined files pattern
# they are the output of bcl2fastq, and serve as an indicator to see if the demultiplexing has finished
demux_indicator = root_dir + '/{run}/demux_data/indicator.log'

# get the mates for each sample
raw_reads_pattern = root_dir + '/{run}/reads/raw/{sample}_R{mate}.fastq.gz'

reverse_reads_pattern = root_dir + '/{run}/reads/reversed/{sample}_reversed_R{mate}.fastq.gz'

# fastqc variables
fastqc_root = root_dir + '/{run}/fastqc/'
fastqc_pattern = fastqc_root + '{sample}_reversed_R{mate}_fastqc.{ext}'
fastqc_command = '/data/rajewsky/shared_bins/FastQC-0.11.2/fastqc'

# create fastqc out list
fastqc_files_out = [expand(fastqc_pattern, run=key, sample=value, mate=[1,2], ext=['html', 'zip']) for key, value in samples.items()]

# flatten the list
fastqc_files_out = [item for sublist in fastqc_files_out for item in sublist]

# Dropseq pipeline
dropseq_root = root_dir + '/{run}'

# create fastqc out list
out_tmp = [expand(reverse_reads_pattern, run=key, sample=value, mate=[1,2]) for key, value in samples.items()]

# flatten the list
out_tmp = [item for sublist in out_tmp for item in sublist]

#############
# Main rule #
#############
rule all:
    input:
        out_tmp

rule demultiplex_data:
    params:
        samplesheet=lambda wildcards: runs[wildcards.run]['samplesheet'],
        flowcell_id=lambda wildcards: runs[wildcards.run]['flowcell_id'],
        output_dir= lambda wildcards: expand(demux_out, run=wildcards.run)
    output:
        demux_indicator
    shell:
        """
        bcl2fastq \
            --no-lane-splitting --fastq-compression-level=9 \
            --mask-short-adapter-reads 15 \
            --barcode-mismatch 1 \
            --output-dir {params.output_dir} \
            --sample-sheet {params.samplesheet} \
            --runfolder-dir /data/remote/basecalls/{params.flowcell_id}

        echo "demux finished: $(date)" > {output}
        """

rule link_raw_reads:
    output:
        raw_reads_pattern
    input:
        demux_indicator
    # isntead of hard links the link is now relative 
    shell:
        """
        mkdir -p {wildcards.run}/reads/raw

        find {root_dir}/{wildcards.run}/demux_data -type f -wholename '*/{wildcards.sample}/*R{wildcards.mate}*.fastq.gz' -exec ln -s ../../../../{{}} {output} \; 
        """

rule reverse_first_mate:
    input:
        root_dir + '{run}/reads/raw/{sample}_R1.fastq.gz'
    output:
        root_dir + '{run}/reads/reversed/{sample}_reversed_R1.fastq.gz'
    params:
        tmp_file_pattern = lambda wildcards: root_dir + wildcards.run + '/reads/reversed/' + wildcards.sample + '_small'
    script:
        'scripts/reverse_fastq_file.py'

rule reverse_second_mate:
    input:
        root_dir + '{run}/reads/raw/{sample}_R2.fastq.gz'
    output:
        root_dir + '{run}/reads/reversed/{sample}_reversed_R2.fastq.gz'
    shell:
        """
        mkdir -p {wildcards.run}/reads/reversed

        ln -s {input} {output}
        """

rule run_fastqc:
    input:
        reverse_reads_pattern
    output:
        fastqc_pattern
    params:
        output_dir = fastqc_root 
    threads: 8
    shell:
        """
        mkdir -p {params.output_dir}

        {fastqc_command} -t {threads} -o {params.output_dir} {input}
        """
